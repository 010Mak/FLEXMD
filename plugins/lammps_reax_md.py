from __future__ import annotations

import logging
import tempfile
import shutil
import importlib.util
import math
from pathlib import Path
from typing import List, Tuple
import numpy as np
from ctypes import c_double

from utilities.config import FORCEFIELD_DIR
from utilities.ffield_utils import pick_ffield
from utilities.radii import get_atomic_mass
from simulation.plugin_interface import ForceCalculator
from simulation.system import System

_FS_PER_PS = 1000.0
_MAX_SAFE_DT_PS = 0.001

_ENERGY_GUARD = 5.0e3

_WARMUP_DT_FS = 0.10
_WARMUP_LIMIT = 0.05
_WARMUP_STEPS_LIMIT = 150
_WARMUP_LANGEVIN_STEPS = 200
_LANGEVIN_DAMP_FS = 25.0
_LANGEVIN_SEED = 904297

_CHUNK_MIN = 10
_CHUNK_MAX = 2000

_log = logging.getLogger(__name__)


class ReaxFFPlugin(ForceCalculator):
    NAME = "reaxff"
    CAPABILITY = "reaxff"
    MIN_ATOMS = 1
    MAX_ATOMS = int(1e12)

    @classmethod
    def is_available(cls) -> bool:
        try:
            return importlib.util.find_spec("lammps") is not None
        except Exception:
            return False

    def __init__(
        self,
        ff_path: str | None = None,
        temperature: float = 300.0,
        timestep_ps: float = 0.25,
        qeq_every: int = 1,
        qeq_tol: float = 1.0e-6,
        qeq_maxiter: int = 200,
        qeq_cutlo: float = 0.0,
        qeq_cuthi: float = 10.0,
        qeq_cutoff: float = 10.0,
        qeq_fix: str = "auto",
        box_padding: float = 15.0,
        auto_resize_box: bool = True,
        use_nvt: bool = False,
        nvt_tdamp_ps: float = 0.1,
        prefer_pair: str = "auto",
    ):
        self.ff_path = ff_path
        self.temperature = float(temperature)
        self.timestep_ps = float(timestep_ps)

        self.qeq_every = int(qeq_every)
        self.qeq_tol = float(qeq_tol)
        self.qeq_maxiter = int(qeq_maxiter)
        self.qeq_cutlo = float(qeq_cutlo)
        self.qeq_cuthi = float(qeq_cuthi)
        self.qeq_cutoff = float(qeq_cutoff)
        self.qeq_fix = (qeq_fix or "auto").lower().strip()

        self.box_padding = float(box_padding)
        self.auto_resize_box = bool(auto_resize_box)

        self.use_nvt = bool(use_nvt)
        self.nvt_tdamp_ps = float(nvt_tdamp_ps)

        self.prefer_pair = (prefer_pair or "auto").lower().strip()

        self._lmp = None
        self._tmpdir: Path | None = None
        self._elem_order: List[str] | None = None
        self._data_file: Path | None = None
        self._box_bounds: Tuple[float, float, float, float, float, float] | None = None
        self._integrator_fix: str | None = None
        self._pair_style: str | None = None
        self._last_good_pos: np.ndarray | None = None
        self._have_fq: bool = False

    def _compute_bounds(self, positions: np.ndarray) -> Tuple[float, float, float, float, float, float]:
        mins, maxs = positions.min(axis=0), positions.max(axis=0)
        pad = max(self.box_padding, self.qeq_cutoff + 3.0, self.qeq_cuthi + 3.0)
        xlo, xhi = float(mins[0] - pad), float(maxs[0] + pad)
        ylo, yhi = float(mins[1] - pad), float(maxs[1] + pad)
        zlo, zhi = float(mins[2] - pad), float(maxs[2] + pad)
        return xlo, xhi, ylo, yhi, zlo, zhi

    def _write_data(self, system: System, tmpdir: Path, order: List[str]) -> Path:
        pos = np.asarray(system.positions, dtype=float)
        self._box_bounds = self._compute_bounds(pos)
        dat = tmpdir / "reaxff.data"
        with dat.open("w") as fh:
            fh.write("lammps data generated by mmdfled\n\n")
            fh.write(f"{len(system.atoms)} atoms\n")
            fh.write(f"{len(order)} atom types\n\n")
            xlo, xhi, ylo, yhi, zlo, zhi = self._box_bounds
            fh.write(f"{xlo:.6f} {xhi:.6f} xlo xhi\n")
            fh.write(f"{ylo:.6f} {yhi:.6f} ylo yhi\n")
            fh.write(f"{zlo:.6f} {zhi:.6f} zlo zhi\n\n")
            fh.write("Masses\n\n")
            for idx, elem in enumerate(order, start=1):
                fh.write(f"{idx} {get_atomic_mass(elem):.6f}\n")
            fh.write("\nAtoms # charge\n\n")
            for i, atom in enumerate(system.atoms, start=1):
                t = order.index(atom.element.capitalize()) + 1
                x, y, z = map(float, atom.position.tolist())
                q = float(atom.properties.get("charge", atom.properties.get("formal_charge", 0.0)))
                fh.write(f"{i} {t} {q:.6f} {x:.8f} {y:.8f} {z:.8f}\n")
        return dat

    def _ensure_box(self, positions: np.ndarray) -> None:
        if self._box_bounds is None:
            return
        xlo, xhi, ylo, yhi, zlo, zhi = self._box_bounds
        mins, maxs = positions.min(axis=0), positions.max(axis=0)
        inside = (
            (mins[0] >= xlo) and (maxs[0] <= xhi) and
            (mins[1] >= ylo) and (maxs[1] <= yhi) and
            (mins[2] >= zlo) and (maxs[2] <= zhi)
        )
        if inside:
            return
        if not self.auto_resize_box:
            raise ValueError("positions exceed LAMMPS box; enable auto_resize_box or increase box_padding")
        new_xlo, new_xhi, new_ylo, new_yhi, new_zlo, new_zhi = self._compute_bounds(positions)
        lmp = self._lmp
        assert lmp is not None
        lmp.command(
            f"change_box all x final {new_xlo} {new_xhi} "
            f"y final {new_ylo} {new_yhi} z final {new_zlo} {new_zhi} units box"
        )
        self._box_bounds = (new_xlo, new_xhi, new_ylo, new_yhi, new_zlo, new_zhi)

    def _clear_integrator_fix(self):
        lmp = self._lmp
        if lmp is None:
            return
        if self._integrator_fix:
            try:
                lmp.command("unfix mmd")
            except Exception:
                pass
            self._integrator_fix = None

    def _ensure_integrator_fix(self):
        lmp = self._lmp
        assert lmp is not None
        if self._integrator_fix:
            return
        if self.use_nvt:
            tdamp_fs = max(1.0, self.nvt_tdamp_ps * _FS_PER_PS)
            lmp.command(f"fix mmd all nvt temp {self.temperature} {self.temperature} {tdamp_fs}")
            self._integrator_fix = "nvt"
        else:
            lmp.command("fix mmd all nve")
            self._integrator_fix = "nve"

    def _select_pair_style(self, lmp) -> str:
        pref = self.prefer_pair

        def _has(style_type: str, style_name: str) -> bool:
            try:
                return bool(lmp.has_style(style_type, style_name))
            except Exception:
                return style_name in ("reaxff", "reax/c")

        has_reaxff = _has("pair", "reaxff")
        has_reaxc = _has("pair", "reax/c")

        if pref in ("auto", "reaxff"):
            if has_reaxff:
                return "reaxff"
        if pref == "reax/c":
            if has_reaxff and not has_reaxc:
                _log.warning("prefer_pair='reax/c' requested, but only 'reaxff' is available; using 'reaxff'.")
                return "reaxff"
            if has_reaxc:
                return "reax/c"
        if has_reaxff:
            return "reaxff"
        if has_reaxc:
            return "reax/c"
        raise RuntimeError("reaxff-compatible pair style not found (need 'reaxff' or 'reax/c').")

    def _choose_qeq_fix(self, lmp, pair_style: str) -> str:
        explicit = (self.qeq_fix or "auto").lower().strip()

        def have(style: str) -> bool:
            try:
                return bool(lmp.has_style("fix", style))
            except Exception:
                return style in ("qeq/reaxff", "acks2/reaxff", "qeq/shielded")

        def _map_choice(val: str) -> str | None:
            if val == "reaxff":
                return "qeq/reaxff"
            if val == "acks2":
                return "acks2/reaxff"
            if val == "shielded":
                return "qeq/shielded"
            return None

        if explicit not in ("", "auto", "none"):
            desired = _map_choice(explicit)
            if desired and have(desired):
                return desired
            raise RuntimeError(f"requested qeq fix '{explicit}' not available in this LAMMPS build")

        for fx in ("qeq/shielded", "qeq/reaxff", "acks2/reaxff"):
            if have(fx):
                return fx

        raise RuntimeError("no suitable QEq fix available (need qeq/shielded or qeq/reaxff or acks2/reaxff)")

    def _install_qeq_fix(self, lmp, qeq_style: str, pair_style: str) -> None:
        if self._have_fq:
            try:
                lmp.command("unfix fq")
            except Exception:
                pass
            self._have_fq = False

        if qeq_style == "qeq/shielded":
            lmp.command(
                f"fix fq all qeq/shielded {self.qeq_every} {self.qeq_cutoff} "
                f"{self.qeq_tol} {self.qeq_maxiter} {pair_style}"
            )
        elif qeq_style == "qeq/reaxff":
            lmp.command(
                f"fix fq all qeq/reaxff {self.qeq_every} {self.qeq_cutlo} {self.qeq_cuthi} "
                f"{self.qeq_tol} {pair_style} maxiter {self.qeq_maxiter}"
            )
        else:
            lmp.command(
                f"fix fq all acks2/reaxff {self.qeq_every} {self.qeq_cutoff} "
                f"{self.qeq_tol} {self.qeq_maxiter} {pair_style}"
            )
        self._have_fq = True

    def _configure(self, lmp, ff_file: str, order: List[str]) -> None:
        base_cmds = [
            "units real",
            "atom_style charge",
            "atom_modify map array",
            "boundary f f f",
            f"read_data {self._data_file}",
            "neighbor 2.0 bin",
            "neigh_modify every 1 delay 0 check yes one 10000 page 100000",
        ]
        lmp.commands_list(base_cmds)

        self._pair_style = self._select_pair_style(lmp)
        if self._pair_style == "reax/c":
            lmp.command("pair_style reax/c NULL")
        else:
            lmp.command("pair_style reaxff NULL")

        symbols = " ".join(order)
        lmp.command(f"pair_coeff * * {ff_file} {symbols}")

        qeq_style = self._choose_qeq_fix(lmp, self._pair_style)
        self._install_qeq_fix(lmp, qeq_style, self._pair_style)

        lmp.commands_list([
            "thermo 0",
            "compute cpe all pe",
            f"timestep {self.timestep_ps * _FS_PER_PS}",
            "run 0 post yes",
        ])
        _log.info(
            "reaxff ready: dt_ps=%.6f (fs=%g) temp=%.1f pair=%s qeq=%s",
            self.timestep_ps, self.timestep_ps * _FS_PER_PS, self.temperature, self._pair_style, qeq_style
        )

    def _warmup_reax(self, target_T: float = 300.0) -> None:
        lmp = self._lmp
        assert lmp is not None

        lmp.command("thermo 10")
        try:
            lmp.command("thermo_modify lost warn")
        except Exception:
            pass

        try:
            lmp.command("min_style fire")
        except Exception:
            try:
                lmp.command("min_style cg")
            except Exception:
                pass
        try:
            lmp.command("min_modify line backtrack")
        except Exception:
            pass
        try:
            lmp.command("minimize 1e-6 1e-8 200 2000")
        except Exception:
            pass

        prev_dt_fs = self.timestep_ps * _FS_PER_PS
        lmp.command(f"timestep {_WARMUP_DT_FS}")
        try:
            lmp.command(f"fix warm all nve/limit {_WARMUP_LIMIT}")
            lmp.command(f"run {_WARMUP_STEPS_LIMIT} post yes")
        finally:
            try:
                lmp.command("unfix warm")
            except Exception:
                pass

        try:
            lmp.command(f"fix bath all langevin {target_T} {target_T} {_LANGEVIN_DAMP_FS} {_LANGEVIN_SEED} zero yes")
            lmp.command("fix int all nve")
            lmp.command(f"run {_WARMUP_LANGEVIN_STEPS} post yes")
        finally:
            for fx in ("bath", "int"):
                try:
                    lmp.command(f"unfix {fx}")
                except Exception:
                    pass

        try:
            lmp.command("thermo 0")
            lmp.command("thermo_modify lost error")
        except Exception:
            pass
        lmp.command(f"timestep {prev_dt_fs}")

    def initialize(self, system: System) -> None:
        if self.timestep_ps > _MAX_SAFE_DT_PS:
            raise ValueError(f"reaxff timestep too large: {self.timestep_ps} ps; use <= {_MAX_SAFE_DT_PS} ps")
        try:
            from lammps import lammps as _Lmp
        except Exception as e:
            raise RuntimeError(f"lammps import failed: {e}")

        elements = {a.element.capitalize() for a in system.atoms}
        if self.ff_path is None:
            ff_file, order = pick_ffield(elements, ff_dir=FORCEFIELD_DIR)
        else:
            ff_file, order = self.ff_path, sorted(elements)
        self._elem_order = order

        self._tmpdir = Path(tempfile.mkdtemp(prefix="reaxff_"))
        self._data_file = self._write_data(system, self._tmpdir, order)

        lmp = _Lmp()
        self._lmp = lmp
        self._configure(lmp, ff_file, order)

        self._warmup_reax(target_T=self.temperature)

        self._ensure_integrator_fix()

        self._last_good_pos = np.asarray(system.positions, dtype=np.float64, order="C").copy()

    def _gather_xyzvf(self):
        lmp = self._lmp
        natoms = int(lmp.get_natoms())
        x_ct = lmp.gather_atoms("x", 1, 3)
        v_ct = lmp.gather_atoms("v", 1, 3)
        f_ct = lmp.gather_atoms("f", 1, 3)
        x = np.ctypeslib.as_array(x_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        v = np.ctypeslib.as_array(v_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        f = np.ctypeslib.as_array(f_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        e = float(lmp.extract_compute("cpe", 0, 0))
        return x, v, f, e

    def compute_forces(self, system: System) -> np.ndarray:
        lmp = self._lmp
        assert lmp is not None

        pos = np.asarray(system.positions, dtype=np.float64, order="C")
        if not np.all(np.isfinite(pos)):
            if (
                self._last_good_pos is not None and
                np.all(np.isfinite(self._last_good_pos)) and
                self._last_good_pos.shape == pos.shape
            ):
                _log.warning("non-finite positions detected; restoring last good coordinates before force eval")
                pos = self._last_good_pos.copy()
                system.positions[:] = pos
            else:
                raise ValueError("non-finite positions")

        self._ensure_box(pos)

        natoms = int(lmp.get_natoms())
        if pos.shape != (natoms, 3):
            raise ValueError(f"position shape {pos.shape} != ({natoms}, 3)")

        buf = (c_double * (natoms * 3))(*pos.ravel(order="C"))
        lmp.scatter_atoms("x", 1, 3, buf)
        lmp.command("run 0 post yes")

        e = float(lmp.extract_compute("cpe", 0, 0))
        if (not math.isfinite(e)) or (abs(e) > _ENERGY_GUARD):
            _log.warning("initial run0 energy looks bad (E=%g); considering QEq fallback", e)
            current_pair = (self._pair_style or "reaxff")
            tried = set()
            for alt in ("qeq/shielded", "qeq/reaxff", "acks2/reaxff"):
                if alt in tried:
                    continue
                tried.add(alt)
                try:
                    self._install_qeq_fix(lmp, alt, current_pair)
                    lmp.command("run 0 post yes")
                    e2 = float(lmp.extract_compute("cpe", 0, 0))
                    _log.info("QEq retry with %s gave E=%g", alt, e2)
                    if math.isfinite(e2) and abs(e2) <= _ENERGY_GUARD:
                        break
                except Exception:
                    continue

        f_ct = lmp.gather_atoms("f", 1, 3)
        forces = np.ctypeslib.as_array(f_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()

        self._last_good_pos = pos.copy()
        return forces

    def compute_energy(self, system: System) -> float:
        lmp = self._lmp
        assert lmp is not None
        return float(lmp.extract_compute("cpe", 0, 0))

    def integrate(self, system: System, n_steps: int, dt_ps: float, report_stride: int = 1):
        lmp = self._lmp
        assert lmp is not None
        if dt_ps > _MAX_SAFE_DT_PS:
            raise ValueError(f"reaxff timestep too large: {dt_ps} ps (max {_MAX_SAFE_DT_PS})")

        if abs(dt_ps - self.timestep_ps) > 1e-12:
            self.timestep_ps = float(dt_ps)
            lmp.command(f"timestep {self.timestep_ps * _FS_PER_PS}")

        self._ensure_integrator_fix()

        frames = []
        stride = max(1, int(report_stride))
        total = int(n_steps)
        done = 0
        next_report = min(stride, total)

        while done < total:
            remaining = total - done
            to_report = next_report - done
            chunk = min(max(_CHUNK_MIN, to_report), _CHUNK_MAX, remaining)
            lmp.command(f"run {chunk} post yes")
            done += chunk

            if done >= next_report or done == total:
                x, v, f, e = self._gather_xyzvf()
                frames.append({
                    "step": done,
                    "time_ps": done * self.timestep_ps,
                    "positions": x,
                    "velocities": v,
                    "forces": f,
                    "energy": float(e),
                })
                next_report += stride

        return frames

    def __del__(self):
        try:
            if self._lmp:
                try:
                    if self._have_fq:
                        self._lmp.command("unfix fq")
                except Exception:
                    pass
                try:
                    if self._integrator_fix:
                        self._lmp.command("unfix mmd")
                except Exception:
                    pass
                self._lmp.close()
        except Exception:
            pass
        try:
            if self._tmpdir:
                shutil.rmtree(self._tmpdir, ignore_errors=True)
        except Exception:
            pass
