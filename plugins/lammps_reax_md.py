from __future__ import annotations
import logging, tempfile, shutil, importlib.util
from pathlib import Path
from typing import List, Tuple
import numpy as np
from ctypes import c_double
from utilities.config import FORCEFIELD_DIR
from utilities.ffield_utils import pick_ffield
from utilities.radii import get_atomic_mass
from simulation.plugin_interface import ForceCalculator
from simulation.system import System

_FS_PER_PS = 1000.0
_MAX_SAFE_DT_PS = 0.001
_log = logging.getLogger(__name__)

class ReaxFFPlugin(ForceCalculator):
    NAME = "reaxff"
    CAPABILITY = "reaxff"
    MIN_ATOMS = 1
    MAX_ATOMS = int(1e12)

    @classmethod
    def is_available(cls) -> bool:
        try:
            return importlib.util.find_spec("lammps") is not None
        except Exception:
            return False

    def __init__(
        self,
        ff_path: str | None = None,
        temperature: float = 300.0,
        timestep_ps: float = 0.25,
        qeq_every: int = 1,
        qeq_tol: float = 1.0e-6,
        qeq_maxiter: int = 200,
        qeq_cutlo: float = 0.0,
        qeq_cuthi: float = 10.0,
        qeq_cutoff: float = 10.0,
        qeq_fix: str = "auto",
        box_padding: float = 15.0,
        auto_resize_box: bool = True,
        use_nvt: bool = False,
        nvt_tdamp_ps: float = 0.1,
    ):
        self.ff_path = ff_path
        self.temperature = float(temperature)
        self.timestep_ps = float(timestep_ps)
        self.qeq_every = int(qeq_every)
        self.qeq_tol = float(qeq_tol)
        self.qeq_maxiter = int(qeq_maxiter)
        self.qeq_cutlo = float(qeq_cutlo)
        self.qeq_cuthi = float(qeq_cuthi)
        self.qeq_cutoff = float(qeq_cutoff)
        self.qeq_fix = qeq_fix.lower().strip()
        self.box_padding = float(box_padding)
        self.auto_resize_box = bool(auto_resize_box)
        self.use_nvt = bool(use_nvt)
        self.nvt_tdamp_ps = float(nvt_tdamp_ps)

        self._lmp = None
        self._tmpdir: Path | None = None
        self._elem_order: List[str] | None = None
        self._data_file: Path | None = None
        self._box_bounds: Tuple[float, float, float, float, float, float] | None = None
        self._integrator_fix: str | None = None

    def _compute_bounds(self, positions: np.ndarray) -> Tuple[float, float, float, float, float, float]:
        mins, maxs = positions.min(axis=0), positions.max(axis=0)
        pad = max(self.box_padding, self.qeq_cutoff + 2.0, self.qeq_cuthi + 2.0)
        xlo, xhi = float(mins[0] - pad), float(maxs[0] + pad)
        ylo, yhi = float(mins[1] - pad), float(maxs[1] + pad)
        zlo, zhi = float(mins[2] - pad), float(maxs[2] + pad)
        return xlo, xhi, ylo, yhi, zlo, zhi

    def _write_data(self, system: System, tmpdir: Path, order: List[str]) -> Path:
        pos = np.asarray(system.positions, dtype=float)
        self._box_bounds = self._compute_bounds(pos)
        dat = tmpdir / "reaxff.data"
        with dat.open("w") as fh:
            fh.write("lammps data generated by mmdfled\n\n")
            fh.write(f"{len(system.atoms)} atoms\n")
            fh.write(f"{len(order)} atom types\n\n")
            xlo, xhi, ylo, yhi, zlo, zhi = self._box_bounds
            fh.write(f"{xlo:.6f} {xhi:.6f} xlo xhi\n")
            fh.write(f"{ylo:.6f} {yhi:.6f} ylo yhi\n")
            fh.write(f"{zlo:.6f} {zhi:.6f} zlo zhi\n\n")
            fh.write("Masses\n\n")
            for idx, elem in enumerate(order, start=1):
                fh.write(f"{idx} {get_atomic_mass(elem):.6f}\n")
            fh.write("\nAtoms # charge\n\n")
            for i, atom in enumerate(system.atoms, start=1):
                t = order.index(atom.element.capitalize()) + 1
                x, y, z = map(float, atom.position.tolist())
                q = float(atom.properties.get("charge", atom.properties.get("formal_charge", 0.0)))
                fh.write(f"{i} {t} {q:.6f} {x:.8f} {y:.8f} {z:.8f}\n")
        return dat

    def _choose_qeq_fix(self, lmp) -> str:
        if self.qeq_fix in ("shielded", "reaxff", "acks2"):
            want = [f"qeq/{self.qeq_fix}"]
        else:
            want = ["qeq/shielded", "qeq/reaxff", "acks2/reaxff"]
        for fx in want:
            if lmp.has_style("fix", fx):
                return fx
        raise RuntimeError("no suitable qeq fix available (need qeq/shielded or qeq/reaxff or acks2/reaxff)")

    def _configure(self, lmp, ff_file: str, order: List[str]) -> None:
        symbols = " ".join(order)
        if lmp.has_style("pair", "reaxff"):
            pair_style_cmd = "pair_style reaxff NULL"
        elif lmp.has_style("pair", "reax/c"):
            pair_style_cmd = "pair_style reax/c"
        else:
            raise RuntimeError("reaxff-compatible pair style not found (need reaxff or reax/c)")

        qeq_style = self._choose_qeq_fix(lmp)

        cmds = [
            "units real",
            "atom_style charge",
            "atom_modify map array",
            "boundary f f f",
            f"read_data {self._data_file}",
            "neighbor 2.0 bin",
            "neigh_modify every 1 delay 0 check yes one 10000 page 100000",
            pair_style_cmd,
            f"pair_coeff * * {ff_file} {symbols}",
        ]
        if qeq_style == "qeq/shielded":
            cmds.append(f"fix fq all qeq/shielded {self.qeq_every} {self.qeq_cutoff} {self.qeq_tol} {self.qeq_maxiter} reaxff")
        elif qeq_style == "qeq/reaxff":
            cmds.append(f"fix fq all qeq/reaxff {self.qeq_every} {self.qeq_cutlo} {self.qeq_cuthi} {self.qeq_tol} reaxff maxiter {self.qeq_maxiter}")
        else:
            cmds.append(f"fix fq all acks2/reaxff {self.qeq_every} {self.qeq_cutoff} {self.qeq_tol} {self.qeq_maxiter} reaxff")

        cmds += [
            "thermo 0",
            "compute cpe all pe",
            f"timestep {self.timestep_ps * _FS_PER_PS}",
            "run 0 post no",
        ]
        lmp.commands_list(cmds)
        _log.info("reaxff dt_ps=%.6f (fs=%g) temp=%.1f", self.timestep_ps, self.timestep_ps * _FS_PER_PS, self.temperature)

    def _ensure_box(self, positions: np.ndarray) -> None:
        if self._box_bounds is None:
            return
        xlo, xhi, ylo, yhi, zlo, zhi = self._box_bounds
        mins, maxs = positions.min(axis=0), positions.max(axis=0)
        inside = (mins[0] >= xlo) and (maxs[0] <= xhi) and (mins[1] >= ylo) and (maxs[1] <= yhi) and (mins[2] >= zlo) and (maxs[2] <= zhi)
        if inside:
            return
        if not self.auto_resize_box:
            raise ValueError("positions exceed lammps box; enable auto_resize_box or increase box_padding")
        new_xlo, new_xhi, new_ylo, new_yhi, new_zlo, new_zhi = self._compute_bounds(positions)
        lmp = self._lmp
        assert lmp is not None
        lmp.command(f"change_box all x final {new_xlo} {new_xhi} y final {new_ylo} {new_yhi} z final {new_zlo} {new_zhi} units box")
        self._box_bounds = (new_xlo, new_xhi, new_ylo, new_yhi, new_zlo, new_zhi)

    def _ensure_integrator_fix(self):
        lmp = self._lmp
        assert lmp is not None
        if self._integrator_fix:
            return
        if self.use_nvt:
            tdamp_fs = max(1.0, self.nvt_tdamp_ps * _FS_PER_PS)
            lmp.command(f"fix mmd all nvt temp {self.temperature} {self.temperature} {tdamp_fs}")
            self._integrator_fix = "nvt"
        else:
            lmp.command("fix mmd all nve")
            self._integrator_fix = "nve"

    def initialize(self, system: System) -> None:
        if self.timestep_ps > _MAX_SAFE_DT_PS:
            raise ValueError(f"reaxff timestep too large: {self.timestep_ps} ps; use <= {_MAX_SAFE_DT_PS} ps")
        try:
            from lammps import lammps as _Lmp
        except Exception as e:
            raise RuntimeError(f"lammps import failed: {e}")

        elements = {a.element.capitalize() for a in system.atoms}
        if self.ff_path is None:
            ff_file, order = pick_ffield(elements, ff_dir=FORCEFIELD_DIR)
        else:
            ff_file, order = self.ff_path, sorted(elements)
        self._elem_order = order

        self._tmpdir = Path(tempfile.mkdtemp(prefix="reaxff_"))
        self._data_file = self._write_data(system, self._tmpdir, order)

        lmp = _Lmp()
        self._configure(lmp, ff_file, order)
        self._lmp = lmp
        self._ensure_integrator_fix()
        _log.info("reaxff ready: %d atoms, ff=%s", len(system.atoms), ff_file)

    def _gather_xyzvf(self):
        lmp = self._lmp
        natoms = int(lmp.get_natoms())
        x_ct = lmp.gather_atoms("x", 1, 3)
        v_ct = lmp.gather_atoms("v", 1, 3)
        f_ct = lmp.gather_atoms("f", 1, 3)
        x = np.ctypeslib.as_array(x_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        v = np.ctypeslib.as_array(v_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        f = np.ctypeslib.as_array(f_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        e = float(lmp.extract_compute("cpe", 0, 0))
        return x, v, f, e

    def compute_forces(self, system: System) -> np.ndarray:
        lmp = self._lmp
        assert lmp is not None
        pos = np.asarray(system.positions, dtype=np.float64, order="C")
        if not np.all(np.isfinite(pos)):
            raise ValueError("non-finite positions")
        self._ensure_box(pos)
        natoms = int(lmp.get_natoms())
        if pos.shape != (natoms, 3):
            raise ValueError(f"position shape {pos.shape} != ({natoms}, 3)")
        buf = (c_double * (natoms * 3))(*pos.ravel(order="C"))
        lmp.scatter_atoms("x", 1, 3, buf)
        lmp.command("run 0 post no")
        f_ct = lmp.gather_atoms("f", 1, 3)
        forces = np.ctypeslib.as_array(f_ct, shape=(natoms * 3,)).reshape((natoms, 3)).copy()
        return forces

    def compute_energy(self, system: System) -> float:
        lmp = self._lmp
        assert lmp is not None
        return float(lmp.extract_compute("cpe", 0, 0))

    def integrate(self, system: System, n_steps: int, dt_ps: float, report_stride: int = 1):
        lmp = self._lmp
        assert lmp is not None
        if dt_ps > _MAX_SAFE_DT_PS:
            raise ValueError(f"reaxff timestep too large: {dt_ps} ps (max {_MAX_SAFE_DT_PS})")
        if abs(dt_ps - self.timestep_ps) > 1e-12:
            self.timestep_ps = float(dt_ps)
            lmp.command(f"timestep {self.timestep_ps * _FS_PER_PS}")
        self._ensure_integrator_fix()

        frames = []
        stride = max(1, int(report_stride))
        for step in range(1, int(n_steps) + 1):
            lmp.command("run 1 post yes")
            if step % stride == 0 or step == n_steps:
                x, v, f, e = self._gather_xyzvf()
                frames.append({
                    "step": step,
                    "time_ps": step * self.timestep_ps,
                    "positions": x,
                    "velocities": v,
                    "forces": f,
                    "energy": float(e),
                })
        return frames

    def __del__(self):
        try:
            if self._lmp:
                self._lmp.close()
        except Exception:
            pass
        try:
            if self._tmpdir:
                shutil.rmtree(self._tmpdir, ignore_errors=True)
        except Exception:
            pass
